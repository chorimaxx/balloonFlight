<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç†±æ°—çƒãƒ•ãƒ©ã‚¤ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ (å´é¢ãƒ“ãƒ¥ãƒ¼)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* èƒŒæ™¯ã®ç©ºã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ */
        .sky-bg {
            background: linear-gradient(to bottom, #4facfe 0%, #00f2fe 100%);
        }

        /* æ°—çƒã‚’ãƒ‘ã‚¹ã®ä¸­å¿ƒã«åˆã‚ã›ã‚‹ãŸã‚ã®èª¿æ•´ */
        #balloon-group {
            transform-origin: center bottom;
        }
    </style>
</head>

<body class="bg-gray-100 min-h-screen font-sans text-gray-800">

    <div class="max-w-5xl mx-auto p-4 sm:p-6 lg:p-8">

        <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
        <header class="mb-6 text-center">
            <h1 class="text-3xl font-bold text-gray-800 flex items-center justify-center gap-3">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-red-500" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path
                        d="M12 2C7.5 2 4 5.5 4 10c0 4.1 3 7.6 7 8.8V21a1 1 0 0 0 2 0v-2.2c4-.12 7-4.7 7-8.8 0-4.5-3.5-8-8-8z" />
                    <path d="M10.5 21h3" />
                    <path d="M12 21v2" />
                    <rect x="10" y="21" width="4" height="3" rx="1" />
                </svg>
                ç†±æ°—çƒãƒ•ãƒ©ã‚¤ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            </h1>
            <p class="text-gray-600 mt-2">KMLãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã€ç§»å‹•è·é›¢ã¨é«˜åº¦ã®å´é¢ãƒ“ãƒ¥ãƒ¼ã‚’ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã—ã¾ã™ã€‚</p>
        </header>

        <!-- ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ« -->
        <div class="bg-white rounded-xl shadow-md p-5 mb-6">
            <div class="flex flex-col lg:flex-row items-center justify-between gap-6">

                <div class="flex flex-col md:flex-row items-center gap-6 w-full lg:w-auto flex-1">
                    <!-- ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã¸æˆ»ã‚‹ãƒœã‚¿ãƒ³ -->
                    <div class="relative w-full md:w-auto shrink-0">
                        <button onclick="location.href='index.html'"
                            class="w-full md:w-auto bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-6 rounded-lg shadow transition duration-200 flex items-center justify-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                            </svg>
                            ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã«æˆ»ã‚‹
                        </button>
                    </div>

                    <!-- ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ãƒœã‚¿ãƒ³ -->
                    <div class="relative w-full md:w-auto shrink-0">
                        <input type="file" id="kml-input" accept=".kml" class="hidden" />
                        <button id="upload-btn"
                            class="w-full md:w-auto bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg shadow transition duration-200 flex items-center justify-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                            </svg>
                            KMLãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
                        </button>
                        <div id="file-name" class="text-sm text-gray-500 mt-2 text-center md:text-left">ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“
                        </div>
                    </div>

                    <!-- ãƒ•ãƒ©ã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ (æ¨ªé•·) -->
                    <div
                        class="flex-1 w-full bg-gray-50 rounded-lg p-3 border border-gray-100 flex flex-wrap items-center justify-between gap-4">
                        <div class="flex flex-wrap items-center gap-x-6 gap-y-2 text-sm">
                            <div class="flex items-center gap-2"><span class="text-gray-500">é«˜åº¦:</span><span
                                    class="font-mono text-blue-600 font-bold text-base" id="info-alt">0 ft</span></div>
                            <div class="flex items-center gap-2"><span class="text-gray-500">ç§»å‹•è·é›¢:</span><span
                                    class="font-mono text-green-600 font-bold text-base" id="info-dist">0.00 km</span>
                            </div>
                            <div class="flex items-center gap-2"><span class="text-gray-500">é€²æ—:</span><span
                                    class="font-mono text-purple-600 font-bold text-base" id="info-progress">0:00 /
                                    0:00</span></div>
                        </div>
                        <div id="time-mode-info" class="text-xs text-gray-500 font-medium">KMLã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„</div>
                    </div>
                </div>

                <!-- å†ç”Ÿã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
                <div class="flex items-center gap-3 w-full lg:w-auto shrink-0 opacity-50 pointer-events-none justify-center lg:justify-end border-t lg:border-t-0 lg:border-l pt-4 lg:pt-0 lg:pl-6"
                    id="playback-controls">
                    <button id="play-btn"
                        class="bg-green-500 hover:bg-green-600 text-white p-3 rounded-full shadow transition duration-200"
                        title="å†ç”Ÿ/ä¸€æ™‚åœæ­¢">
                        <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none"
                            viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                    </button>
                    <button id="reset-btn"
                        class="bg-gray-200 hover:bg-gray-300 text-gray-700 p-3 rounded-full shadow transition duration-200"
                        title="ãƒªã‚»ãƒƒãƒˆ">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                            stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                        </svg>
                    </button>
                    <div class="flex flex-col ml-2">
                        <label for="speed-slider" class="text-xs text-gray-500 mb-1">å†ç”Ÿé€Ÿåº¦</label>
                        <!-- æœ€å°å€¤ã‚’0.25ã«ã€ã‚¹ãƒ†ãƒƒãƒ—ã‚‚0.25ã«å¤‰æ›´ -->
                        <input type="range" id="speed-slider" min="0.25" max="5" step="0.25" value="1"
                            class="w-24 accent-blue-600">
                    </div>
                </div>
            </div>
        </div>

        <!-- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
        <div class="bg-white rounded-xl shadow-md overflow-hidden relative">

            <!-- SVGã‚­ãƒ£ãƒ³ãƒã‚¹ -->
            <div class="w-full h-[500px] sky-bg relative">
                <!-- ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ¡ãƒ¼ã‚¿ãƒ¼ (å³ä¸Šã«é…ç½®) -->
                <div id="speedometer-container"
                    class="absolute top-4 right-4 z-10 bg-white/20 backdrop-blur-sm rounded-full p-2 border border-white/30 shadow-lg hidden">
                    <svg width="120" height="120" viewBox="0 0 100 100">
                        <!-- èƒŒæ™¯å†† -->
                        <circle cx="50" cy="50" r="45" fill="rgba(0,0,0,0.5)" stroke="#fff" stroke-width="2" />
                        <!-- ç›®ç››ã‚Š (ç°¡æ˜“) -->
                        <path d="M 20 80 A 42.4 42.4 0 1 1 80 80" fill="none" stroke="#fff" stroke-width="2"
                            stroke-dasharray="1 5" />
                        <!-- é‡ -->
                        <line id="speed-needle" x1="50" y1="50" x2="50" y2="15" stroke="#ef4444" stroke-width="3"
                            stroke-linecap="round" transform="rotate(-120, 50, 50)" />
                        <circle cx="50" cy="50" r="4" fill="#fff" />
                        <!-- ç¾åœ¨é€Ÿåº¦ãƒ†ã‚­ã‚¹ãƒˆ -->
                        <text id="speed-value" x="50" y="70" text-anchor="middle" fill="#fff" font-size="16"
                            font-weight="bold" font-family="monospace">0</text>
                        <text x="50" y="82" text-anchor="middle" fill="#ccc" font-size="8"
                            font-family="sans-serif">km/h</text>
                    </svg>
                </div>


                <svg id="canvas" class="w-full h-full" viewBox="0 0 1000 500" preserveAspectRatio="xMidYMid meet">
                    <!-- å›ºå®šãƒ¬ã‚¤ãƒ¤ãƒ¼ (é«˜åº¦ç›®ç››ã‚Šãªã©ã€ç”»é¢ã«ç•™ã¾ã‚‹ã‚‚ã®) -->
                    <g id="fixed-grid-layer"></g>

                    <!-- ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒ¬ã‚¤ãƒ¤ãƒ¼ (ä¸–ç•Œå…¨ä½“: æ°—çƒãŒ1000mã‚’è¶…ãˆã‚‹ã¨å·¦ã«å‹•ã) -->
                    <g id="world-layer">
                        <!-- åœ°é¢ -->
                        <rect id="ground-rect" x="0" y="450" width="1000" height="50" fill="#4ade80" />
                        <line id="ground-line" x1="0" y1="450" x2="1000" y2="450" stroke="#16a34a" stroke-width="4" />

                        <!-- ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã™ã‚‹è·é›¢ç›®ç››ã‚Š -->
                        <g id="scrolling-grid-layer"></g>

                        <!-- ãƒ•ãƒ©ã‚¤ãƒˆè»Œè·¡ (é€Ÿåº¦ã«å¿œã˜ã¦è‰²ãŒå¤‰ã‚ã‚‹ã‚ˆã†ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–) -->
                        <g id="flight-path-base"></g>
                        <g id="flight-path-active"></g>

                        <!-- ç†±æ°—çƒã‚¢ã‚¤ã‚³ãƒ³ -->
                        <g id="balloon-group" transform="translate(50, 450)">
                            <!-- é€Ÿåº¦è¡¨ç¤ºç”¨ãƒ†ã‚­ã‚¹ãƒˆ -->
                            <text id="balloon-speed" x="0" y="-105" font-size="12" fill="#1f2937" font-weight="bold"
                                text-anchor="middle" style="text-shadow: 1px 1px 2px rgba(255,255,255,0.9);"></text>

                            <g id="balloon-svg">
                                <path d="M -4,-12 Q 0,-22 4,-12 Q 0,-16 -4,-12 Z" fill="#f97316">
                                    <animate attributeName="opacity" values="0;1;0" dur="0.2s"
                                        repeatCount="indefinite" />
                                </path>

                                <!-- ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ— 1/5 (èµ¤ãƒ»å…¨ä½“ãƒ™ãƒ¼ã‚¹) -->
                                <path
                                    d="M 0,-95 C -55,-95 -60,-35 -15,-15 C -5,-10 5,-10 15,-15 C 60,-35 55,-95 0,-95 Z"
                                    fill="#ef4444" />

                                <!-- ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ— 2/5 (é’) -->
                                <path d="M 0,-95 C -36,-95 -36,-35 -9,-15 C -3,-10 5,-10 15,-15 C 60,-35 55,-95 0,-95 Z"
                                    fill="#3b82f6" />

                                <!-- ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ— 3/5 (ç´«) -->
                                <path d="M 0,-95 C -12,-95 -12,-35 -3,-15 C 2,-10 7,-10 15,-15 C 60,-35 55,-95 0,-95 Z"
                                    fill="#a855f7" />

                                <!-- ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ— 4/5 (é’) -->
                                <path d="M 0,-95 C 12,-95 12,-35 3,-15 C 6,-10 10,-10 15,-15 C 60,-35 55,-95 0,-95 Z"
                                    fill="#3b82f6" />

                                <!-- ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ— 5/5 (ç·‘) -->
                                <path d="M 0,-95 C 36,-95 36,-35 9,-15 C 11,-10 13,-10 15,-15 C 60,-35 55,-95 0,-95 Z"
                                    fill="#22c55e" />

                                <!-- ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ— å¤–æ ç·š (é‡ã­å¡—ã‚Šã®å¢ƒç•Œã‚’ç¶ºéº—ã«æ•´ãˆã‚‹) -->
                                <path
                                    d="M 0,-95 C -55,-95 -60,-35 -15,-15 C -5,-10 5,-10 15,-15 C 60,-35 55,-95 0,-95 Z"
                                    fill="none" stroke="#b91c1c" stroke-width="1.5" stroke-linejoin="round" />

                                <!-- ãƒã‚¹ã‚±ãƒƒãƒˆ -->
                                <rect x="-10" y="-5" width="20" height="12" rx="1.5" fill="#d97706" stroke="#92400e"
                                    stroke-width="1.5" />
                                <line x1="-10" y1="-1" x2="10" y2="-1" stroke="#b45309" stroke-width="1" />
                                <line x1="-10" y1="3" x2="10" y2="3" stroke="#b45309" stroke-width="1" />
                            </g>
                        </g>
                </svg>
            </div>
        </div>
    </div>

    <script>
        // --- çŠ¶æ…‹ç®¡ç† ---
        const state = {
            points: [],        // è§£æã•ã‚ŒãŸåº§æ¨™ãƒ‡ãƒ¼ã‚¿ {lon, lat, alt, dist, time, timeOffset, speed}
            mappedPoints: [],  // SVGåº§æ¨™ç³»ã«ãƒãƒƒãƒ”ãƒ³ã‚°ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ {x, y, alt, dist, timeOffset, speed, color}
            activeLines: [],   // è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆç”¨ã®DOMè¦ç´ å‚ç…§é…åˆ—
            maxDist: 0,
            maxAlt: 0,
            minAlt: 0,
            maxSpeed: 0,       // è¿½åŠ : æœ€é«˜é€Ÿåº¦ (km/h)
            renderMaxAlt: 1200,
            renderMinAlt: 0,
            maxTimeOffset: 0,
            isPlaying: false,
            progress: 0,       // 0 to 1
            animationId: null,
            lastTimestamp: 0,
            duration: 15000,   // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®åŸºæœ¬å†ç”Ÿæ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
            hasRealTimeData: false,
            viewMode: 'scrolling'
        };

        // --- DOMè¦ç´  ---
        const kmlInput = document.getElementById('kml-input');
        const uploadBtn = document.getElementById('upload-btn');
        const fileNameDisplay = document.getElementById('file-name');
        const playbackControls = document.getElementById('playback-controls');
        const playBtn = document.getElementById('play-btn');
        const playIcon = document.getElementById('play-icon');
        const resetBtn = document.getElementById('reset-btn');
        const speedSlider = document.getElementById('speed-slider');
        const flightPathBase = document.getElementById('flight-path-base');
        const flightPathActive = document.getElementById('flight-path-active');
        const balloonGroup = document.getElementById('balloon-group');
        const balloonSpeed = document.getElementById('balloon-speed');
        const infoAlt = document.getElementById('info-alt');
        const infoDist = document.getElementById('info-dist');
        const infoProgress = document.getElementById('info-progress');
        const timeModeInfo = document.getElementById('time-mode-info');

        const speedometerContainer = document.getElementById('speedometer-container');
        const speedNeedle = document.getElementById('speed-needle');
        const speedValue = document.getElementById('speed-value');

        const fixedGridLayer = document.getElementById('fixed-grid-layer');
        const scrollingGridLayer = document.getElementById('scrolling-grid-layer');
        const worldLayer = document.getElementById('world-layer');
        const groundRect = document.getElementById('ground-rect');
        const groundLine = document.getElementById('ground-line');

        let pxPerMeter = 900 / 1000;

        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        uploadBtn.addEventListener('click', () => kmlInput.click());
        kmlInput.addEventListener('change', handleFileUpload);
        playBtn.addEventListener('click', togglePlay);
        resetBtn.addEventListener('click', resetAnimation);

        // --- åˆæœŸåŒ–å‡¦ç† ---
        window.onload = function () {
            balloonGroup.setAttribute('transform', 'translate(50, 450)');
            balloonSpeed.textContent = '';
            worldLayer.setAttribute('transform', 'translate(0, 0)');

            fixedGridLayer.innerHTML = '';
            scrollingGridLayer.innerHTML = '';

            const maxDefAlt = 1200;
            const stepDefAlt = 300;
            for (let alt = 0; alt <= maxDefAlt; alt += stepDefAlt) {
                const y = 450 - (alt / maxDefAlt) * 400;

                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1", "40");
                line.setAttribute("y1", y);
                line.setAttribute("x2", "960");
                line.setAttribute("y2", y);
                line.setAttribute("stroke", "rgba(255,255,255,0.3)");
                line.setAttribute("stroke-dasharray", "4,4");
                fixedGridLayer.appendChild(line);

                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", "35");
                text.setAttribute("y", y + 4);
                text.setAttribute("fill", "#ffffff");
                text.setAttribute("font-size", "12");
                text.setAttribute("text-anchor", "end");
                text.setAttribute("font-weight", "bold");
                text.style.textShadow = "1px 1px 2px rgba(0,0,0,0.5)";
                text.textContent = alt + "ft";
                fixedGridLayer.appendChild(text);
            }

            const distSteps = 10;
            for (let i = 0; i <= distSteps; i++) {
                const dist = 100 * i;
                const x = 50 + dist * pxPerMeter;

                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1", x);
                line.setAttribute("y1", "50");
                line.setAttribute("x2", x);
                line.setAttribute("y2", "460");
                line.setAttribute("stroke", "rgba(255,255,255,0.2)");
                scrollingGridLayer.appendChild(line);

                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", x);
                text.setAttribute("y", "475");
                text.setAttribute("fill", "#1f2937");
                text.setAttribute("font-size", "12");
                text.setAttribute("text-anchor", "middle");
                text.setAttribute("font-weight", "bold");
                text.textContent = dist >= 1000 ? (dist / 1000).toFixed(1) + "km" : dist + "m";
                scrollingGridLayer.appendChild(text);
            }

            // Dashboardã‹ã‚‰ã®è‡ªå‹•èª­ã¿è¾¼ã¿ãƒã‚§ãƒƒã‚¯
            const pendingKml = localStorage.getItem('pending_kml');
            if (pendingKml) {
                fileNameDisplay.textContent = "èª­ã¿è¾¼ã¿æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿";
                const parsedData = parseKML(pendingKml);
                if (parsedData.length >= 2) {
                    prepareFlightData(parsedData);
                    // èª­ã¿è¾¼ã¿å¾Œã€è‡ªå‹•å†ç”Ÿã‚’é–‹å§‹ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
                    // togglePlay(); 
                }
                localStorage.removeItem('pending_kml');
            }
        };

        // --- ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ãƒ»è§£æ ---
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            fileNameDisplay.textContent = file.name;
            const reader = new FileReader();

            reader.onload = function (e) {
                const xmlString = e.target.result;
                const parsedData = parseKML(xmlString);

                if (parsedData.length < 2) {
                    alert('æœ‰åŠ¹ãªçµŒè·¯ãƒ‡ãƒ¼ã‚¿ï¼ˆåº§æ¨™ï¼‰ãŒKMLãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚');
                    return;
                }

                prepareFlightData(parsedData);
            };

            reader.readAsText(file);
        }

        // KMLã®XMLæ–‡å­—åˆ—ã‹ã‚‰åº§æ¨™ã‚’æŠ½å‡º
        function parseKML(xmlString) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, "text/xml");
            let rawPoints = [];

            let customTimeStamps = [];
            const timeStampsIndex = xmlString.indexOf('<!-- time stamps -->');
            if (timeStampsIndex !== -1) {
                const timeStampsSection = xmlString.substring(timeStampsIndex);
                const timeRegex = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})?/g;
                const matches = timeStampsSection.match(timeRegex);
                if (matches) {
                    customTimeStamps = matches.map(t => new Date(t).getTime()).filter(t => !isNaN(t));
                }
            }

            const tracks = xmlDoc.getElementsByTagName("gx:Track");
            if (tracks.length > 0) {
                const track = tracks[0];
                const whens = track.getElementsByTagName("when");
                const coords = track.getElementsByTagName("gx:coord");

                for (let i = 0; i < coords.length; i++) {
                    const parts = coords[i].textContent.trim().split(/\s+/);
                    if (parts.length >= 2) {
                        let time = null;
                        if (i < whens.length) {
                            time = new Date(whens[i].textContent).getTime();
                        }
                        rawPoints.push({
                            lon: parseFloat(parts[0]),
                            lat: parseFloat(parts[1]),
                            alt: parts.length >= 3 ? parseFloat(parts[2]) : 0,
                            time: time
                        });
                    }
                }

                const hasValidTime = rawPoints.length > 0 && rawPoints.every(p => p.time !== null && !isNaN(p.time));
                if (hasValidTime) {
                    return rawPoints;
                }
            }

            rawPoints = [];
            const coordsNodes = xmlDoc.getElementsByTagName("coordinates");
            if (coordsNodes.length > 0) {
                let bestCoords = "";
                for (let i = 0; i < coordsNodes.length; i++) {
                    if (coordsNodes[i].textContent.length > bestCoords.length) {
                        bestCoords = coordsNodes[i].textContent;
                    }
                }

                const coordsArray = bestCoords.trim().split(/\s+/);
                let validCoordIndex = 0;
                for (let pt of coordsArray) {
                    const parts = pt.split(',');
                    if (parts.length >= 2) {
                        let time = null;
                        if (customTimeStamps.length > validCoordIndex) {
                            time = customTimeStamps[validCoordIndex];
                        }
                        rawPoints.push({
                            lon: parseFloat(parts[0]),
                            lat: parseFloat(parts[1]),
                            alt: parts.length >= 3 ? parseFloat(parts[2]) : 0,
                            time: time
                        });
                        validCoordIndex++;
                    }
                }

                const hasValidCoordsTime = rawPoints.length > 0 && rawPoints.every(p => p.time !== null && !isNaN(p.time));
                if (hasValidCoordsTime) {
                    return rawPoints;
                }
            }

            if (rawPoints.length === 0) {
                const gxCoords = xmlDoc.getElementsByTagName("gx:coord");
                for (let i = 0; i < gxCoords.length; i++) {
                    const parts = gxCoords[i].textContent.trim().split(/\s+/);
                    if (parts.length >= 2) {
                        rawPoints.push({
                            lon: parseFloat(parts[0]),
                            lat: parseFloat(parts[1]),
                            alt: parts.length >= 3 ? parseFloat(parts[2]) : 0,
                            time: null
                        });
                    }
                }
            }

            return rawPoints;
        }

        // --- ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ»æ•°å­¦ç³» ---

        function getDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3;
            const Ï†1 = lat1 * Math.PI / 180;
            const Ï†2 = lat2 * Math.PI / 180;
            const Î”Ï† = (lat2 - lat1) * Math.PI / 180;
            const Î”Î» = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(Î”Ï† / 2) * Math.sin(Î”Ï† / 2) +
                Math.cos(Ï†1) * Math.cos(Ï†2) *
                Math.sin(Î”Î» / 2) * Math.sin(Î”Î» / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // åº§æ¨™ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ç´¯ç©è·é›¢ã¨é€Ÿåº¦ã‚’è¨ˆç®—ã—ã€SVGåº§æ¨™ã«ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹æº–å‚™
        function prepareFlightData(rawPoints) {
            state.points = [];
            let cumulativeDist = 0;
            let maxSpeedKmh = 0;

            const hasTimeData = rawPoints.length > 1 && rawPoints[0].time !== null && !isNaN(rawPoints[0].time);
            state.hasRealTimeData = hasTimeData;

            const startAltMeters = rawPoints.length > 0 ? rawPoints[0].alt : 0;
            const mToFt = 3.28084;

            for (let i = 0; i < rawPoints.length; i++) {
                let segmentDist = 0;
                let segmentTimeMs = 0;

                if (i > 0) {
                    const prev = rawPoints[i - 1];
                    const curr = rawPoints[i];
                    segmentDist = getDistance(prev.lat, prev.lon, curr.lat, curr.lon);
                    cumulativeDist += segmentDist;

                    if (hasTimeData) {
                        segmentTimeMs = curr.time - prev.time;
                    }
                }

                let timeOffset = 0;
                let speedMs = 0;

                if (hasTimeData) {
                    timeOffset = rawPoints[i].time - rawPoints[0].time;
                    if (segmentTimeMs > 0) {
                        speedMs = segmentDist / (segmentTimeMs / 1000);
                    }
                } else {
                    timeOffset = cumulativeDist;
                    speedMs = segmentDist > 0 ? 1 : 0; // æ™‚é–“ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã®ä»®ã®é€Ÿåº¦
                }

                const gainedAltFt = (rawPoints[i].alt - startAltMeters) * mToFt;
                const speedKmh = speedMs * 3.6;

                if (speedKmh > maxSpeedKmh) {
                    maxSpeedKmh = speedKmh;
                }

                state.points.push({
                    ...rawPoints[i],
                    dist: cumulativeDist,
                    timeOffset: timeOffset,
                    alt: gainedAltFt,
                    speed: speedKmh // ãã®ãƒã‚¤ãƒ³ãƒˆï¼ˆç›´å‰ã®åŒºé–“ï¼‰ã®é€Ÿåº¦
                });
            }

            state.maxDist = cumulativeDist;
            state.maxTimeOffset = state.points[state.points.length - 1].timeOffset;
            state.maxSpeed = maxSpeedKmh || 30; // 0å‰²å›é¿ã®ãŸã‚ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤

            const altitudes = state.points.map(p => p.alt);
            state.maxAlt = Math.max(...altitudes);
            state.minAlt = Math.min(0, ...altitudes);

            const rawRenderMax = Math.max(state.maxAlt * 1.1, 300);
            state.renderMaxAlt = Math.ceil(rawRenderMax / 300) * 300;
            state.renderMinAlt = Math.floor(Math.min(state.minAlt, 0) / 300) * 300;

            timeModeInfo.textContent = hasTimeData ? "ğŸ•’ å®Ÿéš›ã®é£›è¡Œé€Ÿåº¦ã§å†ç¾ä¸­" : "âš ï¸ æ™‚é–“ãƒ‡ãƒ¼ã‚¿ãªã— (ç­‰é€Ÿç§»å‹•)";

            // ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ¡ãƒ¼ã‚¿ãƒ¼ã®è¡¨ç¤º
            if (state.hasRealTimeData) {
                speedometerContainer.classList.remove('hidden');
            } else {
                speedometerContainer.classList.add('hidden');
            }


            mapPointsToSVG();
            drawGrid();
            drawBasePath();

            playbackControls.classList.remove('opacity-50', 'pointer-events-none');
            resetAnimation();
        }

        // å®Ÿãƒ‡ãƒ¼ã‚¿ã‚’SVGã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚µã‚¤ã‚ºã¨è‰²æƒ…å ±ã«ãƒãƒƒãƒ”ãƒ³ã‚°
        function mapPointsToSVG() {
            const paddingX = 50;
            const groundY = 450;
            const heightY = 400;

            state.mappedPoints = state.points.map((p, index) => {
                const x = paddingX + p.dist * pxPerMeter;
                const y = groundY - ((p.alt - state.renderMinAlt) / (state.renderMaxAlt - state.renderMinAlt)) * heightY;

                // é€Ÿåº¦ã«å¿œã˜ãŸè‰²ç›¸(Hue)ã®è¨ˆç®—
                // 0 km/h = 0 (èµ¤), æœ€å¤§é€Ÿåº¦ = 240 (é’)
                const speedRatio = state.maxSpeed > 0 ? Math.min(p.speed / state.maxSpeed, 1) : 0;
                const hue = speedRatio * 240;
                // æ™‚é–“ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯å…¨ã¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®èµ¤ã«ã™ã‚‹
                const color = state.hasRealTimeData ? `hsl(${hue}, 100%, 50%)` : `hsl(0, 100%, 50%)`;

                return { x, y, alt: p.alt, dist: p.dist, timeOffset: p.timeOffset, speed: p.speed, color: color };
            });

            const groundWidth = Math.max(1000, paddingX + state.maxDist * pxPerMeter + 500);
            groundRect.setAttribute("width", groundWidth);
            groundLine.setAttribute("x2", groundWidth);
        }

        // --- æç”»ç³» ---

        // èƒŒæ™¯ã‚°ãƒªãƒƒãƒ‰ã¨ç›®ç››ã‚Šã®æç”»
        function drawGrid() {
            fixedGridLayer.innerHTML = '';
            scrollingGridLayer.innerHTML = '';

            const stepAlt = 300;
            const startAlt = state.renderMinAlt || 0;
            const endAlt = state.renderMaxAlt || 1200;

            for (let alt = startAlt; alt <= endAlt; alt += stepAlt) {
                const y = 450 - ((alt - startAlt) / (endAlt - startAlt)) * 400;

                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1", "40");
                line.setAttribute("y1", y);
                line.setAttribute("x2", "960");
                line.setAttribute("y2", y);
                line.setAttribute("stroke", "rgba(255,255,255,0.3)");
                line.setAttribute("stroke-dasharray", "4,4");
                fixedGridLayer.appendChild(line);

                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", "35");
                text.setAttribute("y", y + 4);
                text.setAttribute("fill", "#ffffff");
                text.setAttribute("font-size", "12");
                text.setAttribute("text-anchor", "end");
                text.setAttribute("font-weight", "bold");
                text.style.textShadow = "1px 1px 2px rgba(0,0,0,0.5)";
                text.textContent = alt + "ft";
                fixedGridLayer.appendChild(text);
            }

            const isFitMode = state.viewMode === 'fit';
            let stepSize = 100;
            let distSteps = Math.ceil(state.maxDist / 100);

            if (isFitMode && state.maxDist > 1000) {
                const roughStep = state.maxDist / 5;
                const order = Math.pow(10, Math.floor(Math.log10(roughStep)));
                stepSize = Math.round(roughStep / order) * order;
                distSteps = Math.ceil(state.maxDist / stepSize);
            }

            for (let i = 0; i <= distSteps; i++) {
                const dist = i * stepSize;
                const x = 50 + dist * pxPerMeter;

                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1", x);
                line.setAttribute("y1", "50");
                line.setAttribute("x2", x);
                line.setAttribute("y2", "460");
                line.setAttribute("stroke", "rgba(255,255,255,0.2)");
                scrollingGridLayer.appendChild(line);

                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", x);
                text.setAttribute("y", "475");
                text.setAttribute("fill", "#1f2937");
                text.setAttribute("font-size", "12");
                text.setAttribute("text-anchor", "middle");
                text.setAttribute("font-weight", "bold");

                if (dist >= 1000) {
                    text.textContent = (dist / 1000).toFixed(1).replace('.0', '') + "km";
                } else {
                    text.textContent = dist + "m";
                }
                scrollingGridLayer.appendChild(text);
            }
        }

        // è»Œè·¡å…¨ä½“ã‚’ç´°ã‹ãªç·šåˆ†ï¼ˆã‚»ã‚°ãƒ¡ãƒ³ãƒˆï¼‰ã«åˆ†ã‘ã¦æç”»ã—ã€è‰²ã‚’å‰²ã‚Šå½“ã¦ã‚‹
        function drawBasePath() {
            flightPathBase.innerHTML = '';
            flightPathActive.innerHTML = '';
            state.activeLines = [];

            if (state.mappedPoints.length === 0) return;

            for (let i = 1; i < state.mappedPoints.length; i++) {
                const p = state.mappedPoints[i];
                const prev = state.mappedPoints[i - 1];

                // å¾…æ©Ÿæ™‚è¡¨ç¤ºç”¨ã®ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ï¼ˆç‚¹ç·šï¼‰
                const baseLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
                baseLine.setAttribute("x1", prev.x);
                baseLine.setAttribute("y1", prev.y);
                baseLine.setAttribute("x2", p.x);
                baseLine.setAttribute("y2", p.y);
                baseLine.setAttribute("stroke", p.color); // é€Ÿåº¦ã«å¿œã˜ãŸè‰²
                baseLine.setAttribute("stroke-width", "3");
                baseLine.setAttribute("stroke-dasharray", "5,5");
                baseLine.setAttribute("opacity", "0.3");
                flightPathBase.appendChild(baseLine);

                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®å®Ÿç·šï¼ˆåˆæœŸçŠ¶æ…‹ã¯éè¡¨ç¤ºï¼‰
                const activeLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
                activeLine.setAttribute("x1", prev.x);
                activeLine.setAttribute("y1", prev.y);
                activeLine.setAttribute("x2", p.x);
                activeLine.setAttribute("y2", p.y);
                activeLine.setAttribute("stroke", p.color); // é€Ÿåº¦ã«å¿œã˜ãŸè‰²
                activeLine.setAttribute("stroke-width", "4");
                activeLine.setAttribute("stroke-linecap", "round");
                activeLine.style.display = "none";
                flightPathActive.appendChild(activeLine);

                // JavaScriptã‹ã‚‰é«˜é€Ÿã«æ“ä½œã§ãã‚‹ã‚ˆã†ã«é…åˆ—ã«ä¿å­˜
                state.activeLines[i] = activeLine;
            }

            // ç¾åœ¨é€šéä¸­ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’æç”»ã™ã‚‹ãŸã‚ã®å‹•çš„ãƒ©ã‚¤ãƒ³
            const currentActiveLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            currentActiveLine.id = "current-active-line";
            currentActiveLine.setAttribute("stroke-width", "4");
            currentActiveLine.setAttribute("stroke-linecap", "round");
            currentActiveLine.style.display = "none";
            flightPathActive.appendChild(currentActiveLine);
        }

        // --- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡ ---

        function togglePlay() {
            if (state.points.length === 0) return;

            state.isPlaying = !state.isPlaying;

            if (state.isPlaying) {
                playIcon.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />`;
                playBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                playBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');

                if (state.progress >= 1) {
                    resetAnimation();
                    state.isPlaying = true;
                }

                state.lastTimestamp = performance.now();
                state.animationId = requestAnimationFrame(animate);
            } else {
                playIcon.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />`;
                playBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                playBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
                cancelAnimationFrame(state.animationId);
            }
        }

        function resetAnimation() {
            state.isPlaying = false;
            state.progress = 0;
            cancelAnimationFrame(state.animationId);

            state.viewMode = 'scrolling';
            pxPerMeter = 900 / 1000;
            if (state.points.length > 0) {
                mapPointsToSVG();
                drawGrid();
                drawBasePath();
                worldLayer.setAttribute('transform', 'translate(0, 0)');
            }

            playIcon.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />`;
            playBtn.classList.add('bg-green-500', 'hover:bg-green-600');
            playBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');

            updateRender(0);
        }

        function switchToFitView() {
            if (state.maxDist <= 1000) return;

            state.viewMode = 'fit';
            pxPerMeter = 900 / state.maxDist;

            mapPointsToSVG();
            drawGrid();
            drawBasePath();

            worldLayer.setAttribute('transform', 'translate(0, 0)');
            updateRender(1);
        }

        function animate(timestamp) {
            if (!state.isPlaying) return;

            const delta = timestamp - state.lastTimestamp;
            state.lastTimestamp = timestamp;

            const speedMultiplier = parseFloat(speedSlider.value);
            const durationMs = state.duration / speedMultiplier;

            state.progress += delta / durationMs;

            if (state.progress >= 1) {
                state.progress = 1;
                updateRender(1);
                togglePlay();
                switchToFitView();

                return;
            }

            updateRender(state.progress);
            state.animationId = requestAnimationFrame(animate);
        }

        // é€²è¡Œåº¦ã«å¿œã˜ãŸæç”»æ›´æ–°
        function updateRender(progress) {
            if (state.mappedPoints.length === 0) return;

            const targetTime = progress * state.maxTimeOffset;

            // ç¾åœ¨åœ°ï¼ˆæ™‚é–“åŸºæº–ï¼‰ã‚’è£œé–“ã§è¦‹ã¤ã‘ã‚‹
            let i = 0;
            while (i < state.mappedPoints.length - 1 && state.mappedPoints[i + 1].timeOffset < targetTime) {
                i++;
            }

            const p1 = state.mappedPoints[i];
            const p2 = state.mappedPoints[i + 1] || p1;

            const segmentTime = p2.timeOffset - p1.timeOffset;
            const ratio = segmentTime === 0 ? 0 : (targetTime - p1.timeOffset) / segmentTime;

            const currentX = p1.x + (p2.x - p1.x) * ratio;
            const currentY = p1.y + (p2.y - p1.y) * ratio;
            const currentAlt = p1.alt + (p2.alt - p1.alt) * ratio;
            const currentDist = p1.dist + (p2.dist - p1.dist) * ratio;

            // æ°—çƒä¸Šã®é€Ÿåº¦ãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤º
            let speedText = "";
            if (state.hasRealTimeData) {
                speedText = p2.speed.toFixed(1) + " km/h";
            } else {
                speedText = "0.0 km/h";
            }

            // æ°—çƒã®ç§»å‹•
            balloonGroup.setAttribute('transform', `translate(${currentX}, ${currentY})`);
            balloonSpeed.textContent = speedText;

            // ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ¡ãƒ¼ã‚¿ãƒ¼ã®æ›´æ–°
            if (state.hasRealTimeData) {
                const currentSpeed = p2.speed;

                // é‡ã®å›è»¢ (-120åº¦ ã‹ã‚‰ 120åº¦)
                // maxSpeedã‚’100%ã¨ã—ãŸæ™‚ã®å‰²åˆã§è¨ˆç®—ï¼ˆæœ€ä½ã§ã‚‚30km/hã‚¹ã‚±ãƒ¼ãƒ«ã«ã™ã‚‹ï¼‰
                const displayMax = Math.max(state.maxSpeed, 30);
                const speedRatio = Math.min(currentSpeed / displayMax, 1);
                const angle = -120 + (speedRatio * 240);
                speedNeedle.setAttribute('transform', `rotate(${angle}, 50, 50)`);
                speedValue.textContent = Math.round(currentSpeed);
            }

            // ä¸–ç•Œã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« (ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿ã€æ°—çƒãŒ1000mã‚’è¶…ãˆãŸã‚‰å·¦ã¸æµã™)
            let scrollX = 0;
            if (state.viewMode === 'scrolling' && currentDist > 1000) {
                scrollX = -(currentDist - 1000) * pxPerMeter;
            }
            worldLayer.setAttribute('transform', `translate(${scrollX}, 0)`);

            // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ã‚¹ï¼ˆé€šéæ¸ˆã¿ã®è»Œè·¡ï¼‰ã®è¡¨ç¤ºåˆ¶å¾¡
            for (let j = 1; j < state.mappedPoints.length; j++) {
                if (state.activeLines[j]) {
                    // iç•ªç›®ã®ãƒã‚¤ãƒ³ãƒˆã¾ã§ã¯å®Œå…¨ã«é€šéæ¸ˆã¿ãªã®ã§è¡¨ç¤ºã™ã‚‹
                    state.activeLines[j].style.display = (j <= i) ? "block" : "none";
                }
            }

            // ç¾åœ¨é€šéä¸­ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆï¼ˆå‹•çš„ã«é•·ã•ãŒå¤‰ã‚ã‚‹ç·šï¼‰ã®æç”»
            const currentLine = document.getElementById("current-active-line");
            if (ratio > 0 && currentLine) {
                currentLine.setAttribute("x1", p1.x);
                currentLine.setAttribute("y1", p1.y);
                currentLine.setAttribute("x2", currentX);
                currentLine.setAttribute("y2", currentY);
                currentLine.setAttribute("stroke", p2.color);
                currentLine.style.display = "block";
            } else if (currentLine) {
                currentLine.style.display = "none";
            }

            // çµ±è¨ˆæƒ…å ±ã®æ›´æ–°
            infoAlt.textContent = Math.round(currentAlt) + ' ft';
            infoDist.textContent = (currentDist / 1000).toFixed(2) + ' km';

            // é€²æ—ã‚’æ™‚é–“è¡¨ç¤ºï¼ˆåˆ†:ç§’ï¼‰ã«å¤‰æ›´
            const formatTime = (ms) => {
                if (isNaN(ms) || ms < 0) return "0:00";
                const totalSeconds = Math.floor(ms / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            };

            infoProgress.textContent = `${formatTime(targetTime)} / ${formatTime(state.maxTimeOffset)}`;
        }

    </script>
</body>

</html>